# Changelog - 2025-12-20 (Session 6)

## Fixed Thinking Intensity Modal State Sync & Duplicate Tool Output Blocks

- **Goal**: Resolve thinking intensity modal reverting to previous value and duplicate tool use block rendering
- **Risk Level**: Low - Bug fixes only, no API changes, all changes backward compatible
- **Commit**: `9aa5e1c`

Two critical UI bugs were fixed: thinking intensity modal would revert to "hard" when switching to "think", and tool use results would render duplicate output blocks. Root causes were identified as JavaScript falsy value handling, missing state synchronization, and component lifecycle issues.

---

## ✅ No Breaking Changes

All fixes are backward compatible. No API signatures, configuration keys, or message formats were altered in breaking ways.

---

## Environment & Dependencies

| Type | Status | Notes |
|------|--------|-------|
| Node/npm | No change | Existing `npm run compile` workflow sufficient |
| TypeScript | No change | All changes compile without errors |
| VS Code API | No change | Uses existing message routing |

---

## Fixed

### Bug #1: Duplicate Tool Use Block Rendering

**Problem**: When executing MCP tools like Perplexity search, the output block ("OUT") would render twice despite being sent only once.

**Root Cause**: Tool-use and tool-result messages were not being matched for de-duplication. Tool-result messages had `toolUseId` but tool-use messages didn't, causing them to be rendered as separate blocks.

**Solution**: Added `toolUseId: content.id` to tool-use message data in `_parseJsonLine()` at `src/extension.ts:1376`. This ensures tool-use and tool-result messages can be properly matched and merged into a single UI block with IN/OUT sections.

**Files Changed**:
- `src/extension.ts` - Added `toolUseId` to tool-use message structure

### Bug #2: Thinking Intensity Modal State Reversion

**Problem**: When switching thinking intensity from "hard" to "think" and confirming, the modal would revert to "hard" when reopened within ~1-2 seconds. Switching had to be done twice for the setting to persist visually.

**Root Causes** (Multiple issues combined):

1. **Backend blocking I/O**: `_updateSettings()` was awaiting VS Code's `config.update()` which performs disk writes (~500ms-1.5s delay), blocking the function and delaying confirmation to frontend.

2. **No persistence confirmation**: Frontend had no way to verify backend actually persisted the setting, only the initial store update from the user interaction.

3. **Stale component state**: Modal component's internal `selectedLevel` state could persist across open/close cycles if not properly remounted.

4. **Falsy value bug**: The critical bug - the level-to-intensity mapping used `||` (logical OR) instead of `??` (nullish coalescing). Since level 0 is falsy, `INTENSITY_TO_LEVEL['think'] || 1` returned `1` ("Hard") instead of `0` ("Think").

**Solutions**:

1. **Non-blocking config updates** (`src/extension.ts`):
   - Removed `async` keyword from `_updateSettings()`
   - Removed all `await` calls on `config.update()`
   - Fire off updates asynchronously with `.then()/.catch()` handlers
   - VS Code handles persistence in background
   - Function returns immediately instead of waiting for disk I/O

2. **Backend confirmation messages** (`src/extension.ts`):
   - Added `settingUpdated` message sent after backend successfully persists setting
   - Includes key and value confirmation for verification

3. **Frontend confirmation handler** (`src/webview/hooks/useVSCodeMessaging.ts`):
   - Added `settingUpdated` case handler
   - Maps backend config keys back to frontend store keys
   - Re-updates store with confirmed persisted values
   - Prevents stale queries from overwriting frontend state

4. **Modal component remounting** (`src/webview/App.tsx`):
   - Added `key` prop based on modal open state: `key={think-modal-${activeModal === 'thinkingIntensity'}`
   - Forces React to fully destroy/recreate modal instance on open/close
   - Ensures fresh state initialization every time modal opens

5. **Fixed falsy value handling** (`src/webview/components/organisms/thinking-intensity-modal.tsx`):
   - Changed `INTENSITY_TO_LEVEL[currentIntensity] || 1` to `INTENSITY_TO_LEVEL[currentIntensity] ?? 1`
   - Nullish coalescing (`??`) only falls back on `null`/`undefined`, not falsy values like `0`
   - Critical fix: level 0 ("Think") now maps correctly instead of falling back to level 1

**Files Changed**:
- `src/extension.ts` - Non-blocking config updates, added `settingUpdated` confirmation
- `src/webview/hooks/useVSCodeMessaging.ts` - Added `settingUpdated` handler
- `src/webview/App.tsx` - Added key prop to modal for remounting
- `src/webview/components/organisms/thinking-intensity-modal.tsx` - Fixed nullish coalescing operators (2 locations)

---

## Changed

### `src/extension.ts` - `_updateSettings()` function signature and behavior

**Before**: Async function that awaits config writes
```typescript
private async _updateSettings(settings: { [key: string]: any }): Promise<void> {
  // ...
  await config.update(configKey, value, target);
  // Blocks until disk write completes (~500ms-1.5s)
}
```

**After**: Synchronous function with background async updates
```typescript
private _updateSettings(settings: { [key: string]: any }): void {
  // ...
  Promise.resolve(config.update(configKey, value, target))
    .then(() => {
      this._postMessage({
        type: 'settingUpdated',
        data: { key: configKey, value }
      });
    })
    .catch((error: any) => {
      console.error(`[Settings] Failed to update ${configKey}:`, error);
    });
}
```

**Impact**: Settings updates return immediately instead of blocking on I/O. Backend confirms persistence via `settingUpdated` message.

---

## Added

### Message Handler: `settingUpdated` in `src/webview/hooks/useVSCodeMessaging.ts`

New message type confirms backend has persisted a setting to disk:

```typescript
case 'settingUpdated': {
  const data = msg.data as { key: string; value: unknown };
  const frontendKey = configToFrontendKey[data.key] || data.key;
  updateSettings({ [frontendKey]: data.value });
  break;
}
```

Maps backend config keys (`'thinking.intensity'`) to frontend store keys (`'thinkingIntensity'`) and updates store with confirmed persisted values.

### Files Summary

| File Path | Status | Notes |
|-----------|--------|-------|
| `src/extension.ts` | Modified | Non-blocking config updates + confirmation messages |
| `src/webview/hooks/useVSCodeMessaging.ts` | Modified | Added `settingUpdated` handler |
| `src/webview/App.tsx` | Modified | Added key prop to thinking intensity modal |
| `src/webview/components/organisms/thinking-intensity-modal.tsx` | **NEW** | Created file + fixed nullish coalescing |

---

## Verification

**Build**: `npm run compile` ✅
- Extension TypeScript compiled successfully
- Webview bundled successfully
- No type errors

**Manual Testing**: ✅
- Switched thinking intensity from "hard" → "think" → "harder" → "ultrathink" → "hard"
- Modal correctly displays selected intensity on reopen
- No state reversion or duplicate renders observed
- Settings persist correctly to VS Code configuration

**Console Logs Verified**:
- Backend logs show non-blocking updates: "Update initiated (async)"
- Confirmation logs show: "Successfully updated" followed by "Confirmed persisted"
- Frontend logs show proper state syncing: "Syncing selectedLevel from prop"

---

## Open Loops & Handoff Context

### Testing Completed
- ✅ Thinking intensity modal state persistence across open/close cycles
- ✅ Settings confirmation message flow (backend → frontend)
- ✅ Tool use block de-duplication and rendering
- ✅ No duplicate output blocks for MCP tool results

### Known Limitations
- Debug logging left in `thinking-intensity-modal.tsx` - can remove after confirming no issues
- Non-blocking config updates mean failures are logged but not exposed to UI - consider adding error toast if needed

### Next Steps
1. Remove debug console logs from `thinking-intensity-modal.tsx` (lines 40-43) once satisfied with stability
2. Optional: Add visual feedback for setting updates (toast notification) if backend confirmation should be visible to user
3. Consider applying same non-blocking pattern to other settings if latency becomes issue elsewhere

### Resume Context
If issues arise:
- Modal state syncing happens in `src/webview/components/organisms/thinking-intensity-modal.tsx` useEffect
- Backend confirmation flow: `extension.ts` sends `settingUpdated` → `useVSCodeMessaging.ts` receives and updates store
- Tool block rendering logic in `src/webview/containers/MessageList.tsx` around line 381 (de-duplication)

---

## Context Manifest

Priority files for next session:
- `src/webview/components/organisms/thinking-intensity-modal.tsx` - Modal state sync, remove debug logs if stable
- `src/extension.ts:3769-3810` - Settings update mechanism
- `src/webview/containers/MessageList.tsx:375-410` - Tool message de-duplication logic
